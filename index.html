<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Berthel’s Biology</title>

  <!-- Latin Modern (via fontsource). If CDN fails, falls back to serif. -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/latin-modern-roman@5.0.19/index.css">

  <!-- SheetJS for XLSX parsing -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --bg0:#06070a;
      --bg1:#0b0d12;
      --line:#1e2430;
      --line2:#2a3140;
      --txt:#f4f6ff;
      --muted:#b9c0d6;
      --muted2:#8f97ac;
      --good:#36d399;
      --bad:#ff4d6d;
      --warn:#ffd166;
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --radius2: 24px;
      --font: "Latin Modern Roman","Computer Modern Serif","Times New Roman",serif;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:var(--font);
      background: radial-gradient(1200px 700px at 15% 20%, #111623 0%, transparent 60%),
                  radial-gradient(900px 500px at 85% 35%, #0f1320 0%, transparent 55%),
                  linear-gradient(180deg, var(--bg0), var(--bg1));
      color:var(--txt);
      letter-spacing:.1px;
      font-size: 20px; /* larger */
    }
    body::before{
      content:"";
      position:fixed; inset:0;
      background: radial-gradient(900px 520px at 50% 0%, rgba(255,255,255,.05), transparent 60%);
      pointer-events:none;
    }

    .wrap{
      max-width: 1100px;
      margin: 26px auto 60px;
      padding: 0 18px;
    }

    /* Header */
    .hero{
      display:flex;
      align-items:center;
      gap: 18px;
      padding: 18px 22px;
      border: 1px solid var(--line);
      border-radius: var(--radius2);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      box-shadow: var(--shadow);
    }
    .hero-left{
      display:flex;
      align-items:center;
      gap: 16px;
      min-width: 0;
    }
    .avatar{
      width: 60px;
      height: 60px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      object-fit: cover;
      flex: 0 0 auto;
      box-shadow: 0 10px 30px rgba(0,0,0,.4);
    }
    .hero-title{
      display:flex;
      flex-direction:column;
      min-width: 0;
    }
    .hero-title h1{
      margin:0;
      font-size: 36px;
      line-height: 1.05;
      font-weight: 700;
    }
    .hero-title .sub{
      margin-top: 4px;
      color: var(--muted);
      font-size: 19px;
    }
    .hero-right{
      margin-left:auto;
      display:flex;
      align-items:center;
      gap: 10px;
    }
    .version{
      color: var(--muted2);
      font-size: 14px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      white-space: nowrap;
      user-select: none;
    }

    /* Tabs */
    .tabs{
      margin-top: 14px;
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .tab-btn{
      font-family:var(--font);
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      color: var(--txt);
      border-radius: 14px;
      padding: 12px 14px;
      cursor: pointer;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
    }
    .tab-btn:hover{ background: rgba(255,255,255,.06); border-color: rgba(255,255,255,.18); }
    .tab-btn:active{ transform: translateY(1px); }
    .tab-btn.active{
      background: rgba(255,255,255,.10);
      border-color: rgba(255,255,255,.22);
    }

    /* Panels */
    .panel{
      margin-top: 16px;
      border: 1px solid var(--line);
      border-radius: var(--radius2);
      background: rgba(0,0,0,.22);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panel-inner{
      padding: 18px 18px 20px;
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
    }
    .hidden{ display:none !important; }

    .section-title{
      font-size: 24px;
      margin: 0 0 10px;
      font-weight: 700;
    }
    .muted{ color: var(--muted); }

    .divider{
      height: 1px;
      background: var(--line);
      margin: 16px 0;
    }

    /* Controls */
    .row{
      display:flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: end;
    }
    .field{
      flex: 1 1 280px;
      min-width: 240px;
    }
    label{
      display:block;
      font-size: 17px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    input[type="number"], input[type="password"], textarea{
      width:100%;
      font-family: var(--font);
      color: var(--txt);
      background: rgba(0,0,0,.25);
      border: 1px solid var(--line2);
      border-radius: 14px;
      padding: 12px 12px;
      outline: none;
      font-size: 19px;
    }
    textarea{ min-height: 110px; resize: vertical; }

    .btn{
      font-family: var(--font);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 14px;
      padding: 12px 14px;
      cursor:pointer;
      background: rgba(255,255,255,.06);
      color: var(--txt);
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      user-select:none;
    }
    .btn:hover{ background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.28); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: rgba(255,255,255,.92);
      color:#0b0d12;
      border-color: rgba(255,255,255,.92);
      font-weight: 700;
    }
    .btn.primary:hover{ background: rgba(255,255,255,1); }
    .btn.danger{
      background: rgba(255,77,109,.15);
      border-color: rgba(255,77,109,.35);
    }
    .btn.ghost{
      background: transparent;
      border-color: rgba(255,255,255,.12);
      color: var(--muted);
    }

    .chiprow{ display:flex; gap:10px; flex-wrap:wrap; }
    .chip{
      border: 1px solid var(--line2);
      background: rgba(255,255,255,.04);
      color: var(--txt);
      border-radius: 999px;
      padding: 9px 12px;
      cursor:pointer;
      user-select:none;
      font-size: 17px;
    }
    .chip.active{
      background: rgba(255,255,255,.10);
      border-color: rgba(255,255,255,.22);
    }

    /* Status */
    .status{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      color: var(--muted);
      font-size: 17px;
    }
    .status.good{ border-color: rgba(54,211,153,.35); color: rgba(54,211,153,.95); }
    .status.bad{ border-color: rgba(255,77,109,.35); color: rgba(255,77,109,.95); }

    /* Quiz */
    .quiz-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      margin-bottom: 12px;
    }
    .qmeta{
      color: var(--muted);
      font-size: 16px;
    }
    .qstem{
      font-size: 32px;
      font-weight: 800;
      margin: 4px 0 12px;
      line-height: 1.15;
    }
    .qprompt{
      color: var(--muted);
      font-size: 18px;
      margin-bottom: 12px;
    }

    .optlist{
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    .opt{
      display:flex;
      gap: 12px;
      align-items:flex-start;
      padding: 14px 14px;
      border-radius: 16px;
      border: 1px solid var(--line2);
      background: rgba(0,0,0,.20);
      cursor: pointer;
      transition: background .15s ease, border-color .15s ease, transform .06s ease;
      user-select:none;
    }
    .opt:hover{ background: rgba(255,255,255,.05); border-color: rgba(255,255,255,.22); }
    .opt:active{ transform: translateY(1px); }
    .opt.selected{
      border-color: rgba(255,255,255,.55);
      background: rgba(255,255,255,.08);
    }
    .letter{
      width: 36px;
      height: 36px;
      border-radius: 12px;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.16);
      font-weight: 800;
      flex: 0 0 auto;
    }
    .opttext{
      line-height: 1.35;
      font-size: 19px;
    }

    .quiz-nav{
      display:flex;
      gap: 10px;
      align-items:center;
      justify-content:space-between;
      margin-top: 14px;
      flex-wrap: wrap;
    }
    .quiz-nav .left, .quiz-nav .right{ display:flex; gap:10px; align-items:center; }

    /* Summary */
    .summary-kpis{
      display:flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 10px;
    }
    .kpi{
      flex: 1 1 220px;
      border: 1px solid var(--line2);
      background: rgba(0,0,0,.20);
      border-radius: 16px;
      padding: 12px 14px;
    }
    .kpi .big{
      font-size: 30px;
      font-weight: 900;
      margin-bottom: 2px;
    }
    .kpi .small{
      color: var(--muted);
      font-size: 16px;
    }
    .advice{
      margin-top: 12px;
      padding: 12px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: var(--muted);
      line-height: 1.35;
      font-size: 18px;
    }
    .advice strong{ color: var(--txt); }

    .review{
      margin-top: 16px;
      border-top: 1px solid var(--line);
      padding-top: 14px;
    }
    .review-item{
      border: 1px solid var(--line2);
      border-radius: 16px;
      background: rgba(0,0,0,.20);
      padding: 12px 14px;
      margin-bottom: 10px;
    }
    .review-head{
      display:flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    .pill{
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 14px;
      border: 1px solid rgba(255,255,255,.12);
      color: var(--muted);
      background: rgba(255,255,255,.04);
    }
    .pill.good{ border-color: rgba(54,211,153,.35); color: rgba(54,211,153,.95); }
    .pill.bad{ border-color: rgba(255,77,109,.35); color: rgba(255,77,109,.95); }
    .pill.warn{ border-color: rgba(255,209,102,.35); color: rgba(255,209,102,.95); }
    .review-term{
      font-weight: 800;
      font-size: 19px;
      line-height: 1.2;
    }
    .review-body{
      margin-top: 10px;
      color: var(--muted);
      line-height: 1.35;
      font-size: 18px;
    }
    .review-body .line{ margin-top: 6px; }
    .mono{ font-variant-numeric: tabular-nums; }

    /* Updates list */
    .updates{
      display:flex;
      flex-direction:column;
      gap: 10px;
      margin-top: 10px;
    }
    .update{
      border: 1px solid var(--line2);
      border-radius: 16px;
      padding: 12px 14px;
      background: rgba(0,0,0,.20);
    }
    .update .when{
      color: var(--muted2);
      font-size: 14px;
      margin-bottom: 6px;
    }
    .update .text{
      color: var(--txt);
      line-height: 1.35;
    }

    .admin-box{
      border: 1px dashed rgba(255,255,255,.18);
      border-radius: 16px;
      background: rgba(0,0,0,.16);
      padding: 12px 14px;
      margin-top: 14px;
    }
    .admin-row{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: end;
      margin-top: 10px;
    }

    /* File input only used in Custom Content */
    input[type="file"]{
      width:100%;
      font-family:var(--font);
      color: var(--muted);
      font-size: 17px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header class="hero">
      <div class="hero-left">
        <img id="avatar" class="avatar" src="Chinstrap_LOgo.jfif" alt="Avatar"
             onerror="this.onerror=null; this.src=window.__AVATAR_FALLBACK || this.src;">
        <div class="hero-title">
          <h1>Berthel’s Biology</h1>
          <div class="sub">Professional student testing and review workspace.</div>
        </div>
      </div>
      <div class="hero-right">
        <div id="version" class="version">v …</div>
      </div>
    </header>

    <nav class="tabs" aria-label="Tabs">
      <!-- IMPORTANT: type="button" prevents accidental form submission in wrappers (fixes “nothing clickable”). -->
      <button type="button" class="tab-btn active" data-tab="home">Home</button>
      <button type="button" class="tab-btn" data-tab="ev">Etymology &amp; Vocabulary</button>
      <button type="button" class="tab-btn" data-tab="custom">Custom Content</button>
    </nav>

    <!-- HOME -->
    <section id="tab-home" class="panel">
      <div class="panel-inner">
        <h2 class="section-title">Update notes</h2>
        <div class="muted">Updates are timestamped (Beijing time).</div>

        <div id="updates" class="updates"></div>

        <div class="admin-box">
          <div class="muted"><strong>Admin</strong></div>

          <div id="admin-locked">
            <div class="row" style="margin-top:10px;">
              <div class="field">
                <label for="adminPass">Password</label>
                <input id="adminPass" type="password" placeholder="Enter password" autocomplete="current-password" />
              </div>
              <div style="flex:0 0 auto;">
                <button type="button" id="adminLogin" class="btn primary">Unlock</button>
              </div>
            </div>
            <div id="adminMsg" class="status" style="display:none;"></div>
          </div>

          <div id="admin-open" class="hidden">
            <div class="muted" style="margin-top:8px;">
              Add an update note. It will auto-timestamp in Beijing time.
            </div>
            <div class="admin-row">
              <div class="field">
                <label for="updateText">New update message</label>
                <textarea id="updateText" placeholder="Write the update note here…"></textarea>
              </div>
              <div style="flex:0 0 auto;">
                <button type="button" id="addUpdate" class="btn primary">Post update</button>
              </div>
              <div style="flex:0 0 auto;">
                <button type="button" id="adminLock" class="btn ghost">Lock</button>
              </div>
            </div>
            <div class="muted" style="margin-top:10px; font-size:15px;">
              (Notes persist in this browser. For global updates on a static host, paste updates into the HTML or add a backend.)
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- ETY & VOCAB -->
    <section id="tab-ev" class="panel hidden">
      <div class="panel-inner">
        <h2 class="section-title">Etymology &amp; Vocabulary</h2>

        <div class="row">
          <div class="field">
            <label>Mode</label>
            <div class="chiprow" id="modeChips">
              <div class="chip active" data-mode="mixed">Mixed</div>
              <div class="chip" data-mode="vocab">Vocabulary</div>
              <div class="chip" data-mode="ety">Etymology</div>
            </div>
          </div>

          <div class="field">
            <label for="qCountEV">Number of questions (1–100)</label>
            <input id="qCountEV" type="number" min="1" max="100" step="1" inputmode="numeric" placeholder="e.g., 25" />
          </div>

          <div style="flex:0 0 auto;">
            <button type="button" id="startEV" class="btn primary">Start</button>
          </div>
        </div>

        <div id="loadStatus" class="status">Loading master list…</div>

        <!-- Quiz Container -->
        <div id="evStage" class="hidden">
          <div class="divider"></div>

          <div id="quizView">
            <div class="quiz-top">
              <div id="qMeta" class="qmeta mono"></div>
              <button type="button" id="changeNumberEV" class="btn ghost">Change number</button>
            </div>

            <div id="qStem" class="qstem"></div>
            <div id="qPrompt" class="qprompt"></div>

            <div id="optList" class="optlist"></div>

            <div class="quiz-nav">
              <div class="left">
                <button type="button" id="backBtn" class="btn ghost">Back</button>
              </div>
              <div class="right">
                <button type="button" id="finishNowBtn" class="btn danger">Finish now</button>
                <button type="button" id="nextBtn" class="btn primary">Next</button>
              </div>
            </div>
          </div>

          <div id="summaryView" class="hidden"></div>
        </div>
      </div>
    </section>

    <!-- CUSTOM CONTENT -->
    <section id="tab-custom" class="panel hidden">
      <div class="panel-inner">
        <h2 class="section-title">Custom Content</h2>
        <div class="muted">Upload a plain text file formatted as one term–definition per line (use “—” or “:” as separator).</div>

        <div class="row" style="margin-top:12px;">
          <div class="field">
            <label for="customFile">Upload text file</label>
            <input id="customFile" type="file" accept=".txt,.md,.csv" />
          </div>
          <div class="field">
            <label for="qCountCustom">Number of questions (1–100)</label>
            <input id="qCountCustom" type="number" min="1" max="100" step="1" inputmode="numeric" placeholder="e.g., 15" />
          </div>
          <div style="flex:0 0 auto;">
            <button type="button" id="startCustom" class="btn primary">Start</button>
          </div>
        </div>

        <div id="customStatus" class="status">Awaiting upload…</div>

        <div id="customStage" class="hidden">
          <div class="divider"></div>
          <div id="customQuizView"></div>
        </div>
      </div>
    </section>
  </div>

<script>
/* =========================
   Avatar fallback (base64)
   ========================= */
window.__AVATAR_FALLBACK =
  "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQE"+
  "BQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRQBAwME"+
  "DgQHBgkIBwkUDQsMFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU"+
  "FBQUFBQUFBQUFBQUFBQUFP/AABEIAQ0A+gMBIgACEQEDEQH/xAAbAAEAAgMBAQAA"+
  "AAAAAAAAAAAGBQcBAgMEB//EADoQAAIBAgQDBQYEBwAAAAAAAAECAwQRAAUSITFB"+
  "BhMiUWEHMoGRoRQjQlNiscHR8BVCYv/EABcBAQEBAQAAAAAAAAAAAAAAAAABAgP/"+
  "xAAhEQEBAQEAAgIDAQAAAAAAAAABEQIhAxIxQVEiMmFxkf/aAAwDAQACEQMRAD8A"+
  "9u0pV5I9kqm5wK8GJxHkqQ8E1Y3p6y+6o8JqF0cKk0YwW2zZbG3mI8fQnR3iYh8o"+
  "lq4k3h7p8N8bT5p3c5c3m0n9oBv6m4+S1x7m2q0fH2l9t2g2Lw2qgQpJH2c0j5cI"+
  "3VJf0yQ8b4nXKXqE7H6z1y2t3l1m7QbZ7bqB7VQ4xQH4u3m5w7Y1zv5bOq8f7g5"+
  "p+4s0m3b0G2v2aYb5qUoUqVKlSpUqVKlSpUqVKlSpUqVKlSpUqVKlSpUqVKlSpU"+
  "qVKlSpUqVKlSpUqVKlf/2Q==";

/* =========================
   Time helpers (Beijing)
   ========================= */
const TZ = "Asia/Shanghai";

function fmtBeijing(date, withSeconds=false){
  const opt = {
    timeZone: TZ,
    year: "numeric", month:"2-digit", day:"2-digit",
    hour:"2-digit", minute:"2-digit",
    hour12:false
  };
  if(withSeconds) opt.second = "2-digit";
  return new Intl.DateTimeFormat("en-CA", opt).format(date).replace(",", "");
}

function setVersionFromLastModified(){
  const lm = new Date(document.lastModified);
  const dt = isNaN(lm.getTime()) ? new Date() : lm;
  document.getElementById("version").textContent = "v " + fmtBeijing(dt, true);
}

/* =========================
   Tabs (robust)
   ========================= */
function setTab(tab){
  document.querySelectorAll(".tab-btn").forEach(b=>{
    b.classList.toggle("active", b.dataset.tab === tab);
  });
  document.getElementById("tab-home").classList.toggle("hidden", tab !== "home");
  document.getElementById("tab-ev").classList.toggle("hidden", tab !== "ev");
  document.getElementById("tab-custom").classList.toggle("hidden", tab !== "custom");
}

/* =========================
   Updates (Home)
   ========================= */
const UPDATES_KEY = "bb_updates_v1";
const ADMIN_KEY = "bb_admin_unlocked_v1";
const ADMIN_PASSWORD = "temetnosce";

const DEFAULT_UPDATES = [
  {
    when: "—",
    text:
      "Next update: numeric input will accept every integer 1–100; quiz summaries will be complete and more diagnostic; distractors will be generated within the same question type and biased toward semantic similarity for plausibility."
  }
];

function loadUpdates(){
  try{
    const raw = localStorage.getItem(UPDATES_KEY);
    if(!raw) return DEFAULT_UPDATES;
    const arr = JSON.parse(raw);
    if(!Array.isArray(arr) || arr.length===0) return DEFAULT_UPDATES;
    return arr;
  }catch(e){
    return DEFAULT_UPDATES;
  }
}

function saveUpdates(arr){
  localStorage.setItem(UPDATES_KEY, JSON.stringify(arr));
}

function renderUpdates(){
  const box = document.getElementById("updates");
  const arr = loadUpdates();
  box.innerHTML = "";
  arr.forEach(u=>{
    const div = document.createElement("div");
    div.className = "update";
    const when = document.createElement("div");
    when.className = "when mono";
    when.textContent = (u.when && u.when !== "—") ? u.when : "(seeded)";
    const txt = document.createElement("div");
    txt.className = "text";
    txt.textContent = u.text || "";
    div.appendChild(when);
    div.appendChild(txt);
    box.appendChild(div);
  });
}

function setAdminUI(unlocked){
  localStorage.setItem(ADMIN_KEY, unlocked ? "1" : "0");
  document.getElementById("admin-locked").classList.toggle("hidden", unlocked);
  document.getElementById("admin-open").classList.toggle("hidden", !unlocked);
}

/* =========================
   Master list loading (XLSX)
   ========================= */
const MASTER_FILE = "Vocab_Ety_Master_List.xlsx";
let MASTER = { vocab: [], ety: [], vocabIndex: null, etyIndex: null, loaded: false };

const STOP = new Set([
  "the","a","an","and","or","of","to","in","on","for","with","by","as","is","are","was","were",
  "be","been","being","that","this","these","those","from","at","it","its","into","within",
  "over","under","between","during","before","after","while","which","who","whom","their","there",
  "than","then","also","may","might","can","could","should","would","often","typically","primarily"
]);

function normSpace(s){ return (s||"").toString().replace(/\s+/g," ").trim(); }

function stripExamples(s){
  let t = (s||"").toString();
  t = t.replace(/\bExamples?\s*:\s*.*$/i, "").trim();
  t = t.replace(/\b(e\.g\.|eg)\b.*$/i, "").trim();
  return normSpace(t);
}

function tokenize(s){
  const raw = (s||"")
    .toLowerCase()
    .replace(/[^a-z0-9\s\-]/g," ")
    .replace(/\s+/g," ")
    .trim();
  if(!raw) return [];
  return raw.split(" ").filter(w=>{
    if(!w) return false;
    if(w.length<=2) return false;
    if(STOP.has(w)) return false;
    return true;
  });
}

function wordCount(s){
  const t = normSpace(s);
  if(!t) return 0;
  return t.split(" ").length;
}

function techScore(s){
  const t = (s||"").toString();
  const words = t.split(/\s+/).filter(Boolean);
  let score = 0;
  for(const w of words){
    const hasDigit = /\d/.test(w);
    const hasHyphen = /-/.test(w);
    const long = w.replace(/[^A-Za-z]/g,"").length >= 9;
    if(hasDigit || hasHyphen || long) score++;
  }
  return score;
}

function leadClass(s){
  const t = normSpace(s).toLowerCase();
  if(!t) return "none";
  const first = t.split(" ")[0];
  if(first==="the") return "the";
  if(first==="a"||first==="an") return "a";
  if(first.endsWith("ing")) return "ing";
  return "other";
}

function hasConnector(s){
  return /\b(because|therefore|thus|due to|so that|as a result)\b/i.test(s||"");
}

function containsStem(s, stem){
  const a = (s||"").toLowerCase();
  const b = (stem||"").toLowerCase().trim();
  if(!b) return false;
  return a.includes(b);
}

function buildTFIDF(entries){
  const N = entries.length;
  const df = new Map();
  const tfs = [];
  for(const e of entries){
    const toks = tokenize(e.answerText);
    const tf = new Map();
    toks.forEach(w=> tf.set(w,(tf.get(w)||0)+1));
    tfs.push(tf);
    const uniq = new Set(toks);
    uniq.forEach(w=> df.set(w, (df.get(w)||0)+1));
  }
  const idf = new Map();
  df.forEach((v,k)=> idf.set(k, Math.log((N+1)/(v+1))+1));

  const vecs = [];
  const norms = [];
  for(let i=0;i<N;i++){
    const tf = tfs[i];
    let norm = 0;
    const vec = new Map();
    tf.forEach((cnt,w)=>{
      const val = (1 + Math.log(cnt)) * (idf.get(w) || 1);
      vec.set(w,val);
      norm += val*val;
    });
    norms.push(Math.sqrt(norm) || 1);
    vecs.push(vec);
  }
  return {vecs, norms};
}

function cosine(i, j, vecs, norms){
  const a = vecs[i], b = vecs[j];
  const [small, big] = (a.size <= b.size) ? [a,b] : [b,a];
  let dot = 0;
  small.forEach((va,w)=>{
    const vb = big.get(w);
    if(vb) dot += va*vb;
  });
  return dot / (norms[i]*norms[j]);
}

function buildNeighborLists(entries){
  const {vecs, norms} = buildTFIDF(entries);
  const N = entries.length;
  const neighbors = Array.from({length:N}, ()=>[]);
  for(let i=0;i<N;i++){
    const sims = [];
    for(let j=0;j<N;j++){
      if(i===j) continue;
      sims.push([j, cosine(i,j,vecs,norms)]);
    }
    sims.sort((a,b)=> b[1]-a[1]);
    neighbors[i] = sims.slice(0, 40).map(x=>x[0]);
  }
  return {neighbors};
}

function findHeader(headers, candidates){
  const lower = headers.map(h=>({raw:h, low: String(h).toLowerCase().trim()}));
  for(const cand of candidates){
    const c = cand.toLowerCase().trim();
    const hit = lower.find(h=> h.low === c);
    if(hit) return hit.raw;
  }
  for(const cand of candidates){
    const c = cand.toLowerCase().trim();
    const hit = lower.find(h=> h.low.includes(c));
    if(hit) return hit.raw;
  }
  return null;
}

function rowToEntries(rows, sheetName){
  if(!rows || rows.length===0) return {vocab:[], ety:[]};
  const headers = Object.keys(rows[0] || {});
  const termCol = findHeader(headers, ["term","word","vocabulary","vocab","glossary term","entry"]);
  const defCol  = findHeader(headers, ["definition","meaning","desc","description"]);
  const typeCol = findHeader(headers, ["type","category","section"]);
  const wordPartCol = findHeader(headers, ["word part","wordpart","morpheme","prefix","suffix","root","part"]);
  const exCol = findHeader(headers, ["examples","example"]);
  const topicCol = findHeader(headers, ["topic","unit","chapter","subtopic","code","syllabus","strand"]);

  const outV = [], outE = [];
  const sn = (sheetName||"").toLowerCase();

  for(const r of rows){
    const rawTerm = normSpace(termCol ? r[termCol] : "");
    const rawDef  = normSpace(defCol  ? r[defCol]  : "");
    const rawType = normSpace(typeCol ? r[typeCol] : "");
    const rawWP   = normSpace(wordPartCol ? r[wordPartCol] : "");
    const rawEx   = normSpace(exCol ? r[exCol] : "");
    const topic   = normSpace(topicCol ? r[topicCol] : "");

    let kind = "";
    if(rawType){
      const t = rawType.toLowerCase();
      if(t.includes("ety") || t.includes("word part") || t.includes("morpheme") || t.includes("prefix") || t.includes("suffix") || t.includes("root")) kind = "ety";
      if(t.includes("vocab") || t.includes("glossary") || t.includes("definition")) kind = "vocab";
    }
    if(!kind && (sn.includes("ety") || sn.includes("etym"))) kind = "ety";
    if(!kind && sn.includes("vocab")) kind = "vocab";
    if(!kind){
      if(rawWP && !rawTerm) kind = "ety";
      else if(rawTerm) kind = "vocab";
    }

    if(kind === "vocab"){
      if(!rawTerm || !rawDef) continue;
      outV.push({ kind:"vocab", stem: rawTerm, answerText: rawDef, topic });
    }else if(kind === "ety"){
      const wp = rawWP || rawTerm;
      let meaning = rawDef;
      if(!wp || !meaning) continue;
      meaning = stripExamples(meaning);
      if(!meaning) continue;
      outE.push({ kind:"ety", stem: wp, answerText: meaning, topic });
    }
  }

  return {vocab: outV, ety: outE};
}

async function loadMasterList(){
  const status = document.getElementById("loadStatus");
  status.className = "status";
  status.textContent = "Loading master list…";

  try{
    const res = await fetch(MASTER_FILE, {cache:"no-store"});
    if(!res.ok) throw new Error("Fetch failed: " + res.status);
    const buf = await res.arrayBuffer();
    if(typeof XLSX === "undefined") throw new Error("SheetJS not loaded (XLSX undefined).");

    const wb = XLSX.read(buf, {type:"array"});
    let vocab = [];
    let ety = [];

    wb.SheetNames.forEach(name=>{
      const sheet = wb.Sheets[name];
      const json = XLSX.utils.sheet_to_json(sheet, {defval:""});
      const part = rowToEntries(json, name);
      vocab = vocab.concat(part.vocab);
      ety = ety.concat(part.ety);
    });

    const dedup = (arr)=>{
      const seen = new Set();
      const out = [];
      for(const e of arr){
        const key = (e.stem+"||"+e.answerText).toLowerCase();
        if(seen.has(key)) continue;
        seen.add(key);
        out.push(e);
      }
      return out;
    };
    vocab = dedup(vocab);
    ety = dedup(ety);

    MASTER.vocab = vocab;
    MASTER.ety = ety;
    MASTER.vocabIndex = (vocab.length>=4) ? buildNeighborLists(vocab) : null;
    MASTER.etyIndex = (ety.length>=4) ? buildNeighborLists(ety) : null;
    MASTER.loaded = (vocab.length>=4 || ety.length>=4);

    if(!MASTER.loaded) throw new Error("Parsed too few usable rows.");

    status.className = "status good";
    status.textContent = `Preset loaded. Vocabulary: ${vocab.length}  |  Etymology: ${ety.length}`;
    document.getElementById("evStage").classList.remove("hidden");
  }catch(err){
    MASTER.loaded = false;
    status.className = "status bad";
    status.textContent = "Index failed to load. (If you opened this as a local file, host it or use a local server.)";
    console.error(err);
  }
}

/* =========================
   Quiz engine (Etym/Vocab)
   ========================= */
const LETTERS = ["A","B","C","D"];
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }

function genKey(N){
  const base = Math.floor(N/4);
  const counts = {A:base,B:base,C:base,D:base};
  let rem = N % 4;
  const pick = shuffle(["A","B","C","D"].slice());
  for(let i=0;i<rem;i++) counts[pick[i]]++;

  let key = [];
  for(const L of LETTERS) for(let i=0;i<counts[L];i++) key.push(L);

  for(let tries=0; tries<2000; tries++){
    shuffle(key);
    let ok = true, run = 1;
    for(let i=1;i<key.length;i++){
      run = (key[i]===key[i-1]) ? run+1 : 1;
      if(run>3){ ok=false; break; }
    }
    if(!ok) continue;
    const f={A:0,B:0,C:0,D:0}; key.forEach(x=>f[x]++);
    const vals=Object.values(f), max=Math.max(...vals), min=Math.min(...vals);
    if(max-min>1) ok=false;
    if(ok) return key.slice();
  }
  return key;
}

function groupByTopic(entries){
  const map = new Map();
  entries.forEach((e, idx)=>{
    const t = e.topic ? e.topic : "";
    if(!map.has(t)) map.set(t, []);
    map.get(t).push(idx);
  });
  map.forEach(v=> shuffle(v));
  return map;
}

function sampleWithCoverage(entries, count){
  const topicMap = groupByTopic(entries);
  const topics = Array.from(topicMap.keys());
  const hasMeaningfulTopics = !(topics.length===1 && topics[0]==="");
  const used = new Set();
  const picked = [];

  if(hasMeaningfulTopics){
    let safety = 0;
    while(picked.length < count && safety < 100000){
      safety++;
      for(const t of topics){
        const arr = topicMap.get(t);
        if(!arr || arr.length===0) continue;
        while(arr.length && used.has(arr[arr.length-1])) arr.pop();
        if(!arr.length) continue;
        const idx = arr.pop();
        if(used.has(idx)) continue;
        used.add(idx);
        picked.push(idx);
        if(picked.length >= count) break;
      }
      if(entries.length - used.size <= 0) break;
    }
  }

  if(picked.length < count){
    const all = [...Array(entries.length).keys()].filter(i=>!used.has(i));
    shuffle(all);
    while(picked.length < count && all.length) picked.push(all.pop());
  }

  return picked.map(i=>entries[i]);
}

function overlapCount(a, b){
  const A = new Set(tokenize(a));
  const B = new Set(tokenize(b));
  let c = 0; A.forEach(w=>{ if(B.has(w)) c++; });
  return c;
}

function antiCuePass(stem, options, correctIdx){
  const counts = options.map(o=>wordCount(o.text));
  const sorted = counts.slice().sort((x,y)=>x-y);
  const median = sorted.length ? sorted[Math.floor(sorted.length/2)] : 1;
  const max = Math.max(...counts), min = Math.min(...counts);

  for(const wc of counts){
    if(median>0 && Math.abs(wc - median) > Math.ceil(0.2*median)) return false;
  }
  if(max - min > (median<=8 ? 3 : 6)) return false;

  const tech = options.map(o=>techScore(o.text));
  const cTech = tech[correctIdx];
  if(cTech >= 2){
    let comparable = 0;
    for(let i=0;i<4;i++){
      if(i===correctIdx) continue;
      if(tech[i] >= Math.max(1, cTech-1)) comparable++;
    }
    if(comparable < 2) return false;
  }

  const hedge = options.map(o=>/\b(always|never|only|typically|primarily)\b/i.test(o.text));
  if(hedge[correctIdx]){
    let others = 0; for(let i=0;i<4;i++) if(i!==correctIdx && hedge[i]) others++;
    if(others===0) return false;
  }

  const conn = options.map(o=>hasConnector(o.text));
  if(conn[correctIdx]){
    let others = 0; for(let i=0;i<4;i++) if(i!==correctIdx && conn[i]) others++;
    if(others===0) return false;
  }

  const hit = options.map(o=>containsStem(o.text, stem));
  if(hit[correctIdx]){
    let others = 0; for(let i=0;i<4;i++) if(i!==correctIdx && hit[i]) others++;
    if(others===0) return false;
  }
  return true;
}

function buildOptionSet(entry, pool, indexData, desiredLetter){
  const correctText = entry.answerText;
  const stem = entry.stem;
  const correctLead = leadClass(correctText);
  const correctTopic = entry.topic || "";

  const neighbors = indexData?.neighbors || [];
  const i = pool.indexOf(entry);
  const top = (i>=0 && neighbors[i]) ? neighbors[i].slice() : [];

  const sameTopic = [];
  if(correctTopic){
    for(let j=0;j<pool.length;j++){
      if(j===i) continue;
      if((pool[j].topic||"") === correctTopic) sameTopic.push(j);
    }
  }

  let candidates = [];
  if(sameTopic.length >= 6){
    const topSet = new Set(top);
    const inTop = sameTopic.filter(x=>topSet.has(x));
    const rest = sameTopic.filter(x=>!topSet.has(x));
    candidates = inTop.concat(rest);
  }else{
    candidates = top.slice();
  }
  if(candidates.length < 12) candidates = candidates.concat([...Array(pool.length).keys()]);

  candidates = candidates.filter(j=>{
    if(j===i) return false;
    const txt = pool[j].answerText;
    if(!txt) return false;
    if(txt.toLowerCase() === correctText.toLowerCase()) return false;
    if(overlapCount(correctText, txt) < 2) return false;

    const cHasStem = containsStem(correctText, stem);
    const dHasStem = containsStem(txt, stem);
    if(!cHasStem && dHasStem) return false;

    const lc = leadClass(txt);
    if(correctLead !== "other" && lc !== correctLead) return false;

    const wcC = wordCount(correctText);
    const wcD = wordCount(txt);
    if(wcC>0){
      const lo = Math.floor(wcC*0.70), hi = Math.ceil(wcC*1.30);
      if(wcD < lo || wcD > hi) return false;
    }
    return true;
  });
  candidates = Array.from(new Set(candidates));

  const keyIdx = LETTERS.indexOf(desiredLetter);
  for(let t=0;t<220;t++){
    const cap = Math.min(candidates.length, (t<140 ? 24 : 60));
    const pickFrom = candidates.slice(0, cap);
    if(pickFrom.length < 3) break;

    const chosen = new Set();
    while(chosen.size < 3 && pickFrom.length){
      const j = pickFrom[Math.floor(Math.random()*pickFrom.length)];
      chosen.add(j);
      if(chosen.size<3 && t%3===0){
        const k = candidates[Math.min(candidates.length-1, 24 + Math.floor(Math.random()*20))];
        if(k!==undefined) chosen.add(k);
      }
    }
    if(chosen.size < 3) continue;

    let distractors = Array.from(chosen).slice(0,3).map(j=> pool[j].answerText);
    shuffle(distractors);

    const opts = [];
    let d = 0;
    for(let k=0;k<4;k++){
      if(k===keyIdx) opts.push({letter: LETTERS[k], text: correctText, isCorrect:true});
      else opts.push({letter: LETTERS[k], text: distractors[d++], isCorrect:false});
    }
    if(!antiCuePass(stem, opts, keyIdx)) continue;
    return opts;
  }

  // hard fallback
  const all = [...Array(pool.length).keys()].filter(j=>j!==i);
  shuffle(all);
  const dist = [];
  for(const j of all){
    if(dist.length>=3) break;
    const txt = pool[j].answerText;
    if(!txt) continue;
    if(overlapCount(correctText, txt) < 1) continue;
    dist.push(txt);
  }
  while(dist.length<3) dist.push("—");
  shuffle(dist);

  const opts = [];
  let d=0;
  for(let k=0;k<4;k++){
    if(k===keyIdx) opts.push({letter:LETTERS[k], text:correctText, isCorrect:true});
    else opts.push({letter:LETTERS[k], text:dist[d++], isCorrect:false});
  }
  return opts;
}

function makeQuestion(entry, keyLetter){
  const kind = entry.kind;
  const pool = (kind==="vocab") ? MASTER.vocab : MASTER.ety;
  const idx  = (kind==="vocab") ? MASTER.vocabIndex : MASTER.etyIndex;
  const opts = buildOptionSet(entry, pool, idx, keyLetter);
  return {
    kind,
    stem: entry.stem,
    answerText: entry.answerText,
    topic: entry.topic || "",
    prompt: (kind==="vocab") ? "Choose the best definition." : "Choose the best meaning.",
    keyLetter,
    options: opts
  };
}

function validateCount(n){
  const x = Number(n);
  if(!Number.isInteger(x)) return {ok:false, msg:"Enter an integer."};
  if(x<1 || x>100) return {ok:false, msg:"Enter an integer from 1 to 100."};
  return {ok:true, val:x};
}

function buildQuiz(mode, count){
  const hasV = MASTER.vocab.length >= 4;
  const hasE = MASTER.ety.length >= 4;

  let selected = [];
  if(mode==="vocab"){
    if(!hasV) return null;
    selected = sampleWithCoverage(MASTER.vocab, count);
  }else if(mode==="ety"){
    if(!hasE) return null;
    selected = sampleWithCoverage(MASTER.ety, count);
  }else{
    if(hasV && hasE){
      const vCount = Math.ceil(count/2);
      const eCount = count - vCount;
      selected = sampleWithCoverage(MASTER.vocab, vCount).concat(sampleWithCoverage(MASTER.ety, eCount));
      shuffle(selected);
    }else if(hasV){
      selected = sampleWithCoverage(MASTER.vocab, count);
    }else if(hasE){
      selected = sampleWithCoverage(MASTER.ety, count);
    }else return null;
  }

  const key = genKey(selected.length);
  const questions = selected.map((e,i)=> makeQuestion(e, key[i]));

  return {
    mode,
    N: questions.length,
    questions,
    answers: Array(questions.length).fill(null),
    finishedEarly: false
  };
}

/* =========================
   Render Quiz + Summary
   ========================= */
let EV_STATE = null;
let EV_MODE = "mixed";
let qIndex = 0;

const qMeta = document.getElementById("qMeta");
const qStem = document.getElementById("qStem");
const qPrompt = document.getElementById("qPrompt");
const optList = document.getElementById("optList");
const backBtn = document.getElementById("backBtn");
const nextBtn = document.getElementById("nextBtn");
const finishNowBtn = document.getElementById("finishNowBtn");
const summaryView = document.getElementById("summaryView");
const quizView = document.getElementById("quizView");

function computeResults(state){
  let correct = 0, attempted = 0;
  const details = [];
  for(let i=0;i<state.N;i++){
    const q = state.questions[i];
    const ans = state.answers[i];
    const wasAttempted = !!ans;
    if(wasAttempted) attempted++;
    const ok = (ans === q.keyLetter);
    if(ok) correct++;

    const optByLetter = {};
    q.options.forEach(o=> optByLetter[o.letter]=o.text);

    details.push({
      i,
      stem: q.stem,
      kind: q.kind,
      yourLetter: ans,
      correctLetter: q.keyLetter,
      yourText: ans ? optByLetter[ans] : "",
      correctText: optByLetter[q.keyLetter],
      status: !wasAttempted ? "unattempted" : (ok ? "correct" : "incorrect")
    });
  }
  const total = state.N;
  const pct = total ? Math.round((correct/total)*100) : 0;
  const attemptedPct = attempted ? Math.round((correct/attempted)*100) : 0;
  return {correct, total, pct, attempted, attemptedPct, details};
}

function adviceText(pct, attempted, total){
  const unattempted = total - attempted;
  let band;
  if(pct >= 90) band = "high";
  else if(pct >= 75) band = "solid";
  else if(pct >= 60) band = "unstable";
  else band = "low";

  const lines = [];
  lines.push(`<strong>Attempted:</strong> <span class="mono">${attempted}/${total}</span>. Unattempted questions are scored as incorrect (by design).`);
  lines.push(`Distractors were selected from the same question type and biased toward semantic similarity for plausibility.`);

  if(band==="high") lines.push(`Accuracy is strong. Repeat at this size until it stays stable, then increase the question count.`);
  else if(band==="solid") lines.push(`Good trajectory. Retake at the same size until accuracy is stable, then increase the question count.`);
  else if(band==="unstable") lines.push(`Not stable yet. Reduce the question count, retake, and only increase once accuracy holds.`);
  else lines.push(`If you missed many, reduce the question count and retake until accuracy is stable — then increase the question count.`);

  if(unattempted > 0) lines.push(`You ended early with <span class="mono">${unattempted}</span> unattempted. If time pressure caused that, reduce the question count.`);

  return lines.map(s=>`<div class="line">${s}</div>`).join("");
}

function renderQuestion(){
  const s = EV_STATE;
  const q = s.questions[qIndex];
  qMeta.textContent = `Question ${qIndex+1} of ${s.N}`;
  qStem.textContent = q.stem;
  qPrompt.textContent = q.prompt;

  optList.innerHTML = "";
  q.options.forEach((o)=>{
    const div = document.createElement("div");
    div.className = "opt";
    if(s.answers[qIndex] === o.letter) div.classList.add("selected");

    const letter = document.createElement("div");
    letter.className = "letter mono";
    letter.textContent = o.letter;

    const text = document.createElement("div");
    text.className = "opttext";
    text.textContent = o.text;

    div.appendChild(letter);
    div.appendChild(text);

    div.addEventListener("click", (ev)=>{
      ev.preventDefault();
      s.answers[qIndex] = o.letter;
      renderQuestion();
    });

    optList.appendChild(div);
  });

  backBtn.disabled = (qIndex===0);
  nextBtn.textContent = (qIndex===s.N-1) ? "Finish" : "Next";
}

function resetEVToSetup(){
  EV_STATE = null;
  qIndex = 0;
  summaryView.classList.add("hidden");
  quizView.classList.remove("hidden");
  document.getElementById("qCountEV").value = "";
}

function renderSummary(){
  const res = computeResults(EV_STATE);

  quizView.classList.add("hidden");
  summaryView.classList.remove("hidden");

  const parts = [];
  parts.push(`
    <div class="quiz-top">
      <div class="qmeta mono">Results</div>
      <button type="button" id="changeNumberEV2" class="btn ghost">Change number</button>
    </div>
    <div class="section-title" style="margin-top:0;">Summary</div>
    <div class="summary-kpis">
      <div class="kpi"><div class="big mono">${res.correct}/${res.total}</div><div class="small">Score (unattempted count as incorrect)</div></div>
      <div class="kpi"><div class="big mono">${res.pct}%</div><div class="small">Overall accuracy</div></div>
      <div class="kpi"><div class="big mono">${res.attempted}/${res.total}</div><div class="small">Attempted</div></div>
      <div class="kpi"><div class="big mono">${res.attempted ? res.attemptedPct : 0}%</div><div class="small">Accuracy on attempted</div></div>
    </div>
    <div class="advice">${adviceText(res.pct, res.attempted, res.total)}</div>

    <div class="quiz-nav">
      <div class="left">
        <button type="button" id="retakeSame" class="btn">Retake same quiz</button>
        <button type="button" id="newQuiz" class="btn primary">New quiz</button>
      </div>
      <div class="right">
        <button type="button" id="toggleReview" class="btn ghost">Show review</button>
      </div>
    </div>

    <div id="reviewBlock" class="review hidden">
      <div class="section-title" style="font-size:20px;">Review (all questions)</div>
      ${res.details.map(d=>{
        const typeLabel = (d.kind==="vocab") ? "Vocabulary" : "Etymology";
        const pill = d.status==="correct" ? "pill good" : (d.status==="incorrect" ? "pill bad" : "pill warn");
        const label = d.status==="correct" ? "Correct" : (d.status==="incorrect" ? "Incorrect" : "Unattempted");
        return `
          <div class="review-item">
            <div class="review-head">
              <div class="review-term">${d.stem}</div>
              <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                <span class="pill">${typeLabel}</span>
                <span class="${pill}">${label}</span>
                <span class="pill mono">Q${d.i+1}</span>
              </div>
            </div>
            <div class="review-body">
              <div class="line"><span class="muted">Correct:</span> <span class="mono">${d.correctLetter}</span>. ${d.correctText}</div>
              <div class="line"><span class="muted">Your answer:</span> ${d.yourLetter ? `<span class="mono">${d.yourLetter}</span>. ${d.yourText}` : `<span class="mono">—</span>`}</div>
            </div>
          </div>
        `;
      }).join("")}
    </div>
  `);

  summaryView.innerHTML = parts.join("");

  document.getElementById("changeNumberEV2").addEventListener("click",(ev)=>{ ev.preventDefault(); resetEVToSetup(); });
  document.getElementById("retakeSame").addEventListener("click",(ev)=>{
    ev.preventDefault();
    EV_STATE.answers = Array(EV_STATE.N).fill(null);
    EV_STATE.finishedEarly = false;
    qIndex = 0;
    summaryView.classList.add("hidden");
    quizView.classList.remove("hidden");
    renderQuestion();
  });
  document.getElementById("newQuiz").addEventListener("click",(ev)=>{ ev.preventDefault(); resetEVToSetup(); });
  document.getElementById("toggleReview").addEventListener("click",(ev)=>{
    ev.preventDefault();
    const blk = document.getElementById("reviewBlock");
    const show = blk.classList.contains("hidden");
    blk.classList.toggle("hidden", !show);
    ev.target.textContent = show ? "Hide review" : "Show review";
  });
}

/* =========================
   Mode chips
   ========================= */
function setMode(mode){
  EV_MODE = mode;
  document.querySelectorAll("#modeChips .chip").forEach(c=>{
    c.classList.toggle("active", c.dataset.mode===mode);
  });
}

/* =========================
   Custom Content (simple)
   ========================= */
function parseCustomText(text){
  const lines = (text||"").split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  const entries = [];
  for(const line of lines){
    let parts = null;
    if(line.includes("—")) parts = line.split("—");
    else if(line.includes("–")) parts = line.split("–");
    else if(line.includes(":")) parts = line.split(":");
    if(!parts || parts.length < 2) continue;
    const left = normSpace(parts.shift());
    const right = normSpace(parts.join(":"));
    if(left && right) entries.push({ kind:"vocab", stem:left, answerText:right, topic:"" });
  }
  const seen = new Set(); const out = [];
  for(const e of entries){
    const k = (e.stem+"||"+e.answerText).toLowerCase();
    if(seen.has(k)) continue;
    seen.add(k); out.push(e);
  }
  return out;
}

function renderCustomQuiz(state, mount){
  mount.innerHTML = "";

  const qMetaC = document.createElement("div");
  qMetaC.className = "qmeta mono";

  const stemC = document.createElement("div");
  stemC.className = "qstem";

  const promptC = document.createElement("div");
  promptC.className = "qprompt";

  const optsC = document.createElement("div");
  optsC.className = "optlist";

  const navC = document.createElement("div");
  navC.className = "quiz-nav";

  let idx = 0;

  function render(){
    const q = state.questions[idx];
    qMetaC.textContent = `Question ${idx+1} of ${state.N}`;
    stemC.textContent = q.stem;
    promptC.textContent = "Choose the best definition.";

    optsC.innerHTML = "";
    q.options.forEach(o=>{
      const div = document.createElement("div");
      div.className = "opt";
      if(state.answers[idx]===o.letter) div.classList.add("selected");

      const L = document.createElement("div");
      L.className = "letter mono";
      L.textContent = o.letter;

      const T = document.createElement("div");
      T.className = "opttext";
      T.textContent = o.text;

      div.appendChild(L); div.appendChild(T);
      div.addEventListener("click",(ev)=>{ ev.preventDefault(); state.answers[idx]=o.letter; render(); });
      optsC.appendChild(div);
    });

    navC.innerHTML = `
      <div class="left">
        <button type="button" class="btn ghost" id="cBack">Back</button>
      </div>
      <div class="right">
        <button type="button" class="btn danger" id="cFinishNow">Finish now</button>
        <button type="button" class="btn primary" id="cNext">${idx===state.N-1 ? "Finish" : "Next"}</button>
      </div>
    `;

    const back = navC.querySelector("#cBack");
    back.disabled = (idx===0);
    back.addEventListener("click",(ev)=>{ ev.preventDefault(); if(idx>0){ idx--; render(); } });

    navC.querySelector("#cNext").addEventListener("click",(ev)=>{
      ev.preventDefault();
      if(idx<state.N-1){ idx++; render(); }
      else{
        const res = computeResults(state);
        mount.innerHTML = `
          <div class="section-title">Summary</div>
          <div class="summary-kpis">
            <div class="kpi"><div class="big mono">${res.correct}/${res.total}</div><div class="small">Score (unattempted count as incorrect)</div></div>
            <div class="kpi"><div class="big mono">${res.pct}%</div><div class="small">Overall accuracy</div></div>
            <div class="kpi"><div class="big mono">${res.attempted}/${res.total}</div><div class="small">Attempted</div></div>
            <div class="kpi"><div class="big mono">${res.attempted ? res.attemptedPct : 0}%</div><div class="small">Accuracy on attempted</div></div>
          </div>
          <div class="advice">${adviceText(res.pct, res.attempted, res.total)}</div>
        `;
      }
    });

    navC.querySelector("#cFinishNow").addEventListener("click",(ev)=>{
      ev.preventDefault();
      const res = computeResults(state);
      mount.innerHTML = `
        <div class="section-title">Summary</div>
        <div class="summary-kpis">
          <div class="kpi"><div class="big mono">${res.correct}/${res.total}</div><div class="small">Score (unattempted count as incorrect)</div></div>
          <div class="kpi"><div class="big mono">${res.pct}%</div><div class="small">Overall accuracy</div></div>
          <div class="kpi"><div class="big mono">${res.attempted}/${res.total}</div><div class="small">Attempted</div></div>
          <div class="kpi"><div class="big mono">${res.attempted ? res.attemptedPct : 0}%</div><div class="small">Accuracy on attempted</div></div>
        </div>
        <div class="advice">${adviceText(res.pct, res.attempted, res.total)}</div>
      `;
    });
  }

  mount.appendChild(qMetaC);
  mount.appendChild(stemC);
  mount.appendChild(promptC);
  mount.appendChild(optsC);
  mount.appendChild(navC);
  render();
}

/* =========================
   Wire everything
   ========================= */
function init(){
  setVersionFromLastModified();

  // Tabs (event listeners + preventDefault)
  document.querySelectorAll(".tab-btn").forEach(btn=>{
    btn.addEventListener("click", (ev)=>{
      ev.preventDefault();
      setTab(btn.dataset.tab);
    });
  });

  // Updates
  renderUpdates();
  setAdminUI(localStorage.getItem(ADMIN_KEY)==="1");

  const adminPass = document.getElementById("adminPass");
  const adminMsg = document.getElementById("adminMsg");

  function tryLogin(){
    const pass = (adminPass.value || "").trim();
    adminMsg.style.display = "block";
    if(pass === ADMIN_PASSWORD){
      adminMsg.className = "status good";
      adminMsg.textContent = "Unlocked.";
      setAdminUI(true);
      adminPass.value = "";
      setTimeout(()=>{ adminMsg.style.display="none"; }, 900);
    }else{
      adminMsg.className = "status bad";
      adminMsg.textContent = "Incorrect password.";
    }
  }

  document.getElementById("adminLogin").addEventListener("click",(ev)=>{ ev.preventDefault(); tryLogin(); });
  adminPass.addEventListener("keydown",(ev)=>{ if(ev.key==="Enter"){ ev.preventDefault(); tryLogin(); } });

  document.getElementById("adminLock").addEventListener("click",(ev)=>{ ev.preventDefault(); setAdminUI(false); });

  document.getElementById("addUpdate").addEventListener("click",(ev)=>{
    ev.preventDefault();
    const ta = document.getElementById("updateText");
    const text = normSpace(ta.value);
    if(!text) return;
    const arr = loadUpdates();
    arr.unshift({ when: fmtBeijing(new Date(), true), text });
    saveUpdates(arr);
    ta.value = "";
    renderUpdates();
  });

  // Mode chips
  document.querySelectorAll("#modeChips .chip").forEach(ch=>{
    ch.addEventListener("click",(ev)=>{ ev.preventDefault(); setMode(ch.dataset.mode); });
  });

  // Start EV
  document.getElementById("startEV").addEventListener("click",(ev)=>{
    ev.preventDefault();
    if(!MASTER.loaded) return;
    const v = validateCount(document.getElementById("qCountEV").value);
    const st = document.getElementById("loadStatus");
    if(!v.ok){
      st.className = "status bad";
      st.textContent = v.msg;
      return;
    }
    const quiz = buildQuiz(EV_MODE, v.val);
    if(!quiz){
      st.className = "status bad";
      st.textContent = "Insufficient data for this mode.";
      return;
    }
    EV_STATE = quiz;
    qIndex = 0;
    summaryView.classList.add("hidden");
    quizView.classList.remove("hidden");
    renderQuestion();
  });

  document.getElementById("changeNumberEV").addEventListener("click",(ev)=>{ ev.preventDefault(); resetEVToSetup(); });

  document.getElementById("backBtn").addEventListener("click",(ev)=>{
    ev.preventDefault();
    if(!EV_STATE) return;
    if(qIndex>0){ qIndex--; renderQuestion(); }
  });

  document.getElementById("nextBtn").addEventListener("click",(ev)=>{
    ev.preventDefault();
    if(!EV_STATE) return;
    if(qIndex < EV_STATE.N - 1){ qIndex++; renderQuestion(); }
    else renderSummary();
  });

  document.getElementById("finishNowBtn").addEventListener("click",(ev)=>{
    ev.preventDefault();
    if(!EV_STATE) return;
    EV_STATE.finishedEarly = true;
    renderSummary();
  });

  // Custom
  document.getElementById("startCustom").addEventListener("click", async (ev)=>{
    ev.preventDefault();
    const status = document.getElementById("customStatus");
    const file = document.getElementById("customFile").files[0];
    if(!file){
      status.className = "status bad";
      status.textContent = "Upload a text file first.";
      return;
    }
    const v = validateCount(document.getElementById("qCountCustom").value);
    if(!v.ok){
      status.className = "status bad";
      status.textContent = v.msg;
      return;
    }
    const text = await file.text();
    const entries = parseCustomText(text);
    if(entries.length < 4){
      status.className = "status bad";
      status.textContent = "Could not parse enough term–definition pairs.";
      return;
    }

    const count = Math.min(v.val, entries.length);
    const key = genKey(count);
    const picked = sampleWithCoverage(entries, count);
    const idxData = buildNeighborLists(picked);
    const questions = picked.map((e,i)=>{
      const opts = buildOptionSet(e, picked, idxData, key[i]);
      return { kind:"vocab", stem:e.stem, answerText:e.answerText, prompt:"Choose the best definition.", keyLetter:key[i], options:opts, topic:"" };
    });

    const state = { mode:"custom", N: questions.length, questions, answers: Array(questions.length).fill(null) };

    status.className = "status good";
    status.textContent = `Loaded ${entries.length} pairs. Starting quiz…`;
    document.getElementById("customStage").classList.remove("hidden");
    renderCustomQuiz(state, document.getElementById("customQuizView"));
  });

  // Kick off XLSX load without blocking UI
  loadMasterList();
}

// Ensure init always runs (even in odd wrappers)
if(document.readyState === "loading"){
  document.addEventListener("DOMContentLoaded", init, {once:true});
}else{
  init();
}
</script>
</body>
</html>
